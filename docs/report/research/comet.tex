\section{Comet}

\subsection{History}

\paragraph{} As mentioned before, many different techniques were developed in 
order to palliate the static web pages problem. The Comet programming was one 
of them.

\paragraph{} \cite{wiki-comet} Even though not called as such in the beginning, 
the first Comet implementations date back to 2000. A lot of different projects 
were developed at that time, some of which were proprietary and others open 
source. Among those one could cite the Pushlets open source project: this 
framework was based on server-side Java servlets and on a client-side Javascript 
library; it provided a way to push data from the server to any connected 
browser \cite{pushlets}.

\paragraph{} Other attempts to achieve bi-directional communication between 
client and server were made. The most noticeable one would be a Java-based 
web server  developed by Chip Morningstar\cite{wiki-chip-morningstar} using two 
HTTP sockets to keep two communication channels opened and the server's client 
counterpart designed by Douglas Crockford\cite{wiki-douglas-crockford}. The 
messaging format used between client and server was later named 
JSON\footnote{Javascript Object Notation} which has nowadays become a standard 
in web communications.

\paragraph{} The Comet terminology was introduced by the software engineer 
Alex Russell in a post on his personal blog\cite{alex-russell}. This term was a 
play on the Ajax terminology, Ajax and Comet both being commonly used detergents 
in America.

\subsubsection{Implementations}

\paragraph{} As mentioned in the previous paragraphs, many different 
implementations exist for the Comet technique, each having its counterparts. I 
will briefly present both of them and I will give a simple chat 
application protocol using the second one.

\paragraph{Streaming} An application using the streaming Comet technique will 
open a single persistent connection between client and server. This connection 
will later be used to transmit various Comet events.
\paragraph{} This type of Comet programming can be achieved using an "inifinite"
iframe tag inside an HTML page, which is done by manipulating HTTP headers to 
lead the browser to believe that data are sent in multiple chunks (see  
\cite{webreference-infinite-iframe} 
for more details). Another way is to use an XMLHttpRequest object by tricking 
the client's browser into making it believe that the message is 
made of multiple parts, thus allowing the server to transfer data without 
needing to reopen a connection.


\begin{center}
    \includegraphics[width=0.48\textwidth]{imgs/comet-longpolling.jpg}
    \captionof{figure}{Ajax long-polling \cite{ibm-reverse-ajax}}
\end{center}

\paragraph{Ajax long polling} The Comet streaming technique has the 
disadvantage of depending on the browser, thus forcing different fallback 
systems to be implemented in order to support every browser. Ajax long polling 
will 
not solve every compatibility issues between browsers but at least this 
technique will work as long as the XHR support is present.

\paragraph{} To implement such a technique, one can use an XMLHttpRequest 
object: the client will issue an asynchronous request to the server, which can 
wait for data to be ready before answering the request. Once the request is 
answered, the client will issue a new request to the server waiting for new 
data 
to be available and will then restart this cycle.

\paragraph{} A second way of achieving this technique without worrying about 
CORS\footnote{Cross-Origin Resource Sharing} (a mechanism that allows resources 
to be loaded on a server located outside the main website domain) would be to 
generate dynamically \textless script\textgreater \footnote{ \textless 
script\textgreater tags are used to load scripts into a web page} tags 
referencing resources on the Comet server that will be automatically executed 
by the browser.

\subsection{Chat application}

\paragraph{} The chat application protocol using long 
polling and XMLHttpRequests is pretty straightforward : 

\begin{itemize}
 \item A user displays the page in the browser loading all required Javascript 
dependencies.
 \item The application will create an XMLHttpRequest object and connect to the 
Comet server waiting for new incoming messages. If new data are received, 
it is displayed in the chat interface and a new XHR object is created in order 
to listen to further events.
 \item The user can then write messages in a text field and submit them through 
another XMLHttpRequest object only used to send data.
\end{itemize}

\subsection{Pros and cons}

\paragraph{} Comet technique needs to be thought on a case by case basis, 
browser compatibility is its main disadvantage: a lot of alternatives need to 
be developed in parallel.

\paragraph{} Although we are achieving a low-latency connection between 
client and server, the streaming technique is still not a real bi-directional 
TCP connection.

\paragraph{} The long polling technique is still polling: even if the server 
load is less important in the particular case of a chat application than when 
using Ajax polling, it will require the 
server to handle a lot of new concurrent connections on a regular basis. It 
will also require the use of a server capable of keeping a lot of waiting 
connections for a long time.

\paragraph{} The scalability of this technique will mainly depend on the 
physical resources available on the server or on the way the server dispatches 
tasks to slave machines but it will still be more scalable than the Ajax 
alternative.

\paragraph{} In the case of the Comet Streaming technique, it is easier to test 
whenever a user is disconnected for good as the timeout can be defined as 
shorter than in the previous case. However, the Long-polling technique presents 
the same drawbacks as the Ajax standard polling.